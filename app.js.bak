// Wait for the ENTIRE page, including external scripts, to load
window.addEventListener('load', (event) => {

    // --- VexFlow Setup ---
    const { Factory, Formatter, StaveNote, BarNote, Voice } = Vex.Flow;
    
    // --- Tone.js Setup ---
    const synth = new Tone.Synth().toDestination();
    let currentSequence = null;

    // --- Find the HTML elements ---
    const staffOutput = document.getElementById('staff-output');
    const pianoRoll = document.getElementById('piano-roll');
    const pianoRollLabels = document.getElementById('piano-roll-labels');
    
    // --- Constants ---
    const NUM_MEASURES = 4; // 4 measures
    const TICKS_PER_MEASURE = 384; // 16 * 16th notes
    const TOTAL_TICKS = TICKS_PER_MEASURE * NUM_MEASURES;
    const TICKS_PER_16TH = 24;
    const LINE_HEIGHT = 10; // Height of one line in the piano roll (in px)

    // This map defines our "piano roll" grid, from top to bottom
    const lineIndexToVexKey = [
        "C/6", "B/5", "A/5", "G/5", "F/5", "E/5", "D/5", "C/5", "B/4",
        "A/4", "G/4", "F/4", "E/4", "D/4", "C/4", "B/3", "A/3", "G/3"
    ];
    
    const vexKeyToMidi = {
        "C/6": 72, "B/5": 71, "A/5": 69, "G/5": 67, "F/5": 65, "E/5": 64, "D/5": 62,
        "C/5": 60, "B/4": 59, "A/4": 57, "G/4": 55, "F/4": 53, "E/4": 52, "D/4": 50,
        "C/4": 48, "B/3": 47, "A/3": 45, "G/3": 43, "b/4": 0 // Rests
    };
    // Helper to get VexFlow duration string from tick length
    const lenToDuration = {
        1536: "w", 768: "h", 384: "w", 192: "h", 96: "q", 48: "8", 24: "16"
    };

    // --- The Tune-Dex Data Model ---
    let tuneData = {
      title: "My New Tune",
      events: [] // The "single source of truth"
    };

    // --- Core Drawing Functions ---

    // This runs ONCE to build the static grid
    function buildPianoRollGrid() {
        pianoRoll.innerHTML = ''; // Clear old grid
        pianoRollLabels.innerHTML = ''; // Clear old labels
        
        const rollWidth = pianoRoll.clientWidth;
        
        // --- Draw Grid Lines ---
        lineIndexToVexKey.forEach((key, i) => {
            const line = document.createElement('div');
            line.className = 'piano-roll-line';
            if (key.startsWith('C')) {
                line.classList.add('tonic');
            }
            pianoRoll.appendChild(line);
            
            const label = document.createElement('div');
            label.className = 'piano-roll-label';
            label.textContent = key; // Full key name
            if (key.startsWith('C')) label.classList.add('tonic');
            pianoRollLabels.appendChild(label);
        });

        // 3. Vertical time lines
        for (let t = 0; t <= TOTAL_TICKS; t += TICKS_PER_16TH) {
            const beat = document.createElement('div');
            beat.className = 'piano-roll-beat';
            if (t % TICKS_PER_MEASURE === 0) {
                beat.classList.add('measure');
            }
            beat.style.left = `${(t / TOTAL_TICKS) * 100}%`;
            pianoRoll.appendChild(beat);
        }
    }

    // This draws ONLY the note blocks
    function drawNotesInPianoRoll() {
        // Clear only the note blocks, not the grid
        pianoRoll.querySelectorAll('.note-block').forEach(n => n.remove());
        
        const rollWidth = pianoRoll.clientWidth;
        
        // --- Draw Note Blocks ---
        tuneData.events.forEach(event => {
            const lineIndex = lineIndexToVexKey.indexOf(event.key);
            if (lineIndex === -1 && event.type !== 'rest') return;

            const yPos = lineIndex * LINE_HEIGHT;
            const xPos = (event.pos / TOTAL_TICKS) * 100; // Use percentage
            const width = (event.len / TOTAL_TICKS) * 100; // Use percentage

            const noteBlock = document.createElement('div');
            noteBlock.className = 'note-block';
            noteBlock.style.top = `${yPos}px`;
            noteBlock.style.left = `${xPos}%`;
            noteBlock.style.width = `${width}%`;
            
            noteBlock.dataset.id = event.id; // Use a unique ID

            if (event.type === 'rest') {
                noteBlock.classList.add('rest');
                noteBlock.style.top = `${lineIndexToVexKey.indexOf("B/4") * LINE_HEIGHT}px`;
            }
            pianoRoll.appendChild(noteBlock);
        });
    }
    
    // This draws the "written music" display
    function drawStaff() {
        staffOutput.innerHTML = ''; // Clear old staff
        const vf = new Factory({
            renderer: { elementId: 'staff-output', width: 500, height: 170 },
        });
        const stave = vf.Stave(10, 10, 480);
        stave.addClef('treble').addTimeSignature("4/4");
        
        const context = vf.getContext();
        stave.setContext(context).draw();

        if (tuneData.events.length === 0) {
            console.log("No notes to draw on staff.");
            staffOutput.innerHTML = '<p style="color: #999; text-align: center;">Click "Play" to generate staff notation.</p>';
            return;
        }

        tuneData.events.sort((a, b) => a.pos - b.pos);

        let notes = [];
        let tick = 0;
        const events = [...tuneData.events]; // Work on a copy

        while (tick < TOTAL_TICKS) {
            // Find events at the current tick
            const eventsAtPos = events.filter(e => e.pos === tick);
            
            if (eventsAtPos.length > 0) {
                const keys = eventsAtPos.filter(e => e.type === 'note').map(e => e.key);
                const rest = eventsAtPos.find(e => e.type === 'rest');
                const len = eventsAtPos[0].len; // All notes at one pos have same len
                const duration = lenToDuration[len] || '16';
                
                let note;
                if (keys.length > 0) {
                    note = new StaveNote({ keys: keys, duration: duration, auto_stem: true });
                } else if (rest) {
                    note = new StaveNote({ keys: ["b/4"], duration: duration + "r" });
                }
                
                if (note) {
                    notes.push(note);
                    tick += len; // Move time forward by the note's length
                } else {
                    tick += TICKS_PER_16TH; // Failsafe
                }
            } else {
                // No event, add a rest to fill the gap
                const nextEvent = events.find(e => e.pos > tick);
                const gap = (nextEvent ? nextEvent.pos : TOTAL_TICKS) - tick;
                
                let rests = createRestsForGap(gap);
                notes.push(...rests);
                tick += gap;
            }
        }
        
        // Create a Voice and add the notes
        const voice = new Voice({ num_beats: NUM_MEASURES * 4, beat_value: 4 });
        voice.setStrict(false);
        voice.addTickables(notes);

        // Format and draw
        new Formatter().joinVoices([voice]).format([voice], 400);
        voice.draw(context, stave);
    }

    // Helper for auto-rest logic
    function createRestsForGap(gap) {
        let rests = [];
        let remainingGap = gap;
        const restLens = [1536, 768, 384, 192, 96, 48, 24]; // From 4 measures to 16th
        for (const len of restLens) {
            const duration = lenToDuration[len];
            if (duration && remainingGap >= len) {
                while (remainingGap >= len) {
                    rests.push(new StaveNote({
                        keys: ["b/4"],
                        duration: duration + "r"
                    }));
                    remainingGap -= len;
                }
            }
        }
        return rests;
    }

    // --- Interaction Functions ---
    
    // Helper to find the nearest grid coordinate to a click
    function getGridCoords(e) {
        const rect = pianoRoll.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const lineIndex = Math.floor(y / LINE_HEIGHT);
        const vexKey = lineIndexToVexKey[lineIndex];
        
        const percentX = x / rect.width;
        const tick = percentX * TOTAL_TICKS;
        const snappedTicks = Math.round(tick / TICKS_PER_16TH) * TICKS_PER_16TH;
        
        return { vexKey, snappedTicks };
    }

    // Helper to find if a note exists at a click
    function findEventAtClick(e) {
        const { vexKey, snappedTicks } = getGridCoords(e);
        if (!vexKey) return -1;
        
        for (let i = 0; i < tuneData.events.length; i++) {
            const event = tuneData.events[i];
            if (event.key === vexKey && snappedTicks >= event.pos && snappedTicks < (event.pos + event.len)) {
                return i; // Return the index
            }
        }
        return -1; // Not found
    }
    
    // ** New Interaction Logic **
    
    function handlePianoRollClick(e) {
        const { vexKey, snappedTicks } = getGridCoords(e);
        if (!vexKey) return; 

        // Check if a note is already there
        if (findEventAtClick(e) > -1) {
            console.log("Spot taken. Double-click to remove.");
            return;
        }
        
        // Add the new 16th note
        const newEvent = {
            id: Date.now().toString() + Math.random(), // Unique ID
            type: "note",
            key: vexKey,
            duration: "16",
            pos: snappedTicks,
            len: TICKS_PER_16TH
        };
        
        console.log("Adding event:", newEvent);
        tuneData.events.push(newEvent);
        
        // ** FIX: Start Tone.js *before* playing **
        Tone.start().then(() => {
            synth.triggerAttackRelease(newEvent.key, "16n", Tone.now());
        });
        
        // Redraw only the piano roll
        drawNotesInPianoRoll();
        // Clear the staff to show it's "out of sync"
        staffOutput.innerHTML = '<p style="color: #999; text-align: center;">Click "Play" to update staff</p>';
    }

    function handlePianoRollDoubleClick(e) {
        const eventIndex = findEventAtClick(e); // Find note at click
        
        if (eventIndex > -1) {
            console.log("SUCCESS: Erased event at index:", eventIndex);
            tuneData.events.splice(eventIndex, 1); // Remove it
            
            // Redraw piano roll
            drawNotesInPianoRoll();
            // Clear the staff
            staffOutput.innerHTML = '<p style="color: #999; text-align: center;">Click "Play" to update staff</p>';
        } else {
            console.log("No note found at that position to remove.");
        }
    }

    // --- Audio Playback ---
    async function playMelody() {
        stopMelody(); 
        
        // **This is the "Commit-to-Play" logic**
        // First, redraw the staff based on the current data
        drawStaff();

        const toneEvents = [];
        tuneData.events.forEach(event => {
            if (event.type === 'note') {
                toneEvents.push({
                    time: `${event.pos}i`, // 'i' means ticks
                    note: event.key,
                    duration: `${event.len}i`
                });
            }
        });

        if (toneEvents.length === 0) return;

        await Tone.start();
        Tone.Transport.ticks = 0; // Rewind
        
        currentSequence = new Tone.Part((time, value) => {
            synth.triggerAttackRelease(value.note, value.duration, time);
        }, toneEvents).start(0);
        
        // **Auto-Loop Logic**
        currentSequence.loop = true;
        currentSequence.loopEnd = `${TOTAL_TICKS}i`;
        Tone.Transport.loop = true;
        Tone.Transport.loopEnd = `${TOTAL_TICKS}i`;
        
        Tone.Transport.start();
    }

    function stopMelody() {
        // **Stop/Reset Logic**
        if (currentSequence) {
            currentSequence.stop(0);
            currentSequence.dispose();
            currentSequence = null;
        }
        Tone.Transport.stop();
        Tone.Transport.position = 0; // Reset to beginning
        synth.triggerRelease(); // Stop any "stuck" notes
    }

    // --- Control Functions ---
    function clearAll() {
        console.log("Clearing score");
        stopMelody();
        tuneData.events = [];
        drawNotesInPianoRoll();
        drawStaff();
    }
    
    function generateXpt() {
      // This function works as intended
      console.log("Generating .xpt file...");
      let xmlString = `<?xml version="1.0"?>
    <!DOCTYPE lmms-project>
    <lmms-project type="pattern" creatorversion="1.3.0" creator="Tune-Dex Engine" version="20">
      <head/>
      <pattern type="1" muted="0" steps="16" name="${tuneData.title}" pos="0">\n`;

      tuneData.events.forEach(event => {
        if (event.type === 'note') {
          const midiKey = vexKeyToMidi[event.key] || 48; 
          xmlString += `    <note key="${midiKey}" pan="0" len="${event.len}" pos="${event.pos}" vol="100"/>\n`;
        }
      });

      xmlString += `  </pattern>
    </lmms-project>`;
      
      const blob = new Blob([xmlString], { type: 'application/xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "tune-dex-export.xpt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // --- ** "Tune-Dex" Seed Feature ** ---
    
    // Base64 encode the tune data to create a "seed"
    function generateSeed() {
        if (tuneData.events.length === 0) return;
        const jsonString = JSON.stringify(tuneData.events);
        const seed = btoa(jsonString); // Base64 encode
        
        navigator.clipboard.writeText(seed).then(() => {
            alert("Tune-Dex Seed copied to clipboard!");
        }, () => {
            document.getElementById('seed-input').value = seed;
            alert("Seed copied to input box. Please copy it from there.");
        });
    }
    
    // Decode the "seed" and load the tune
    function loadFromSeed() {
        const seed = document.getElementById('seed-input').value;
        if (!seed) return;
        
        try {
            const jsonString = atob(seed); // Base64 decode
            const newEvents = JSON.parse(jsonString);
            
            if (Array.isArray(newEvents)) {
                tuneData.events = newEvents;
                drawNotesInPianoRoll();
                drawStaff();
            }
        } catch (e) {
            alert("Invalid Tune-Dex Seed.");
            console.error("Seed load error:", e);
        }
    }

    // --- Button Connections ---
    
    document.getElementById('play-button').addEventListener('click', playMelody);
    document.getElementById('stop-button').addEventListener('click', stopMelody);
    document.getElementById('clear-button').addEventListener('click', clearAll);
    document.getElementById('export-xpt-button').addEventListener('click', generateXpt);
    // ** FIX for the crash **
    // The button `export-midi-button` was removed from the HTML,
    // so this line was causing the `addEventListener` crash.
    // document.getElementById('export-midi-button').addEventListener('click', () => {
    //     alert("MIDI export is coming soon!");
    // });
    
    // New Seed button listeners
    document.getElementById('seed-load-button').addEventListener('click', loadFromSeed);
    document.getElementById('seed-share-button').addEventListener('click', generateSeed);
    
    // --- Initial Load & Listener Setup ---
    pianoRoll.addEventListener('click', handlePianoRollClick);
    pianoRoll.addEventListener('dblclick', handlePianoRollDoubleClick);
    
    // Initial Draw
    buildPianoRollGrid(); // Draw the static grid ONCE
    drawNotesInPianoRoll(); // Draw any (0) initial notes
    drawStaff(); // Draw the empty staff

});